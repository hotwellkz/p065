# Backend Environment Variables
# Скопируй этот файл в .env и заполни значения

# ============================================
# Firebase Admin SDK (для доступа к Firestore)
# ============================================
# ВАЖНО: Для бэкенда нужен Service Account, а не обычные Firebase конфигурационные переменные!
# 
# Вариант 1 (рекомендуется): Полный JSON Service Account
# Получи Service Account JSON:
# 1. Открой https://console.firebase.google.com/
# 2. Выбери проект → Project Settings → Service Accounts
# 3. Нажми "Generate new private key"
# 4. Скопируй весь JSON и вставь сюда (в одну строку, в кавычках)
FIREBASE_SERVICE_ACCOUNT={"type":"service_account","project_id":"your-project-id",...}

# ИЛИ Вариант 2: Отдельные переменные из Service Account JSON
# Распарси JSON и используй эти поля:
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_CLIENT_EMAIL=your-service-account@your-project.iam.gserviceaccount.com
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"

# ============================================
# Telegram API (для работы с SyntX)
# ============================================
# Получи на https://my.telegram.org/apps
TELEGRAM_API_ID=12345678
TELEGRAM_API_HASH=your-api-hash-here
SYNX_CHAT_ID=your-syntx-chat-id

# Секретный ключ для шифрования Telegram сессий (32 байта в hex = 64 символа)
# Сгенерируй: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
TELEGRAM_SESSION_SECRET=your-64-char-hex-secret-here

# Зашифрованная Telegram сессия (для Cloud Run / продакшена)
# Получи после успешного логина через: npm run export:telegram-session
# ВАЖНО: Используйте одинаковый TELEGRAM_SESSION_SECRET для шифрования/расшифровки!
TELEGRAM_SESSION_ENCRYPTED=your-encrypted-session-string-here

# ============================================
# Google Drive API (для сохранения видео)
# ============================================
# Получи Service Account для Google Drive:
# 1. Открой https://console.cloud.google.com/
# 2. APIs & Services → Credentials → Create Credentials → Service Account
# 3. Создай Service Account и скачай JSON ключ
# 4. Распарси JSON и используй эти поля:
GOOGLE_DRIVE_CLIENT_EMAIL=your-service-account@your-project.iam.gserviceaccount.com
GOOGLE_DRIVE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
# Опционально: ID папки по умолчанию (если у канала не задан googleDriveFolderId)
GOOGLE_DRIVE_DEFAULT_PARENT=your-default-folder-id

# ============================================
# Google OAuth 2.0 (для персональной интеграции Google Drive)
# ============================================
# Получи OAuth 2.0 credentials для веб-приложения:
# 1. Открой https://console.cloud.google.com/
# 2. APIs & Services → Credentials → Create Credentials → OAuth client ID
# 3. Выбери "Web application"
# 4. Добавь Authorized redirect URIs:
#    - Для разработки: http://localhost:5173/google-drive/callback
#    - Для продакшена: https://your-domain.com/google-drive/callback
# 5. Скопируй Client ID и Client Secret
GOOGLE_CLIENT_ID=your-google-oauth-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-google-oauth-client-secret
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:5173/google-drive/callback
# Для authRoutes.ts используется GOOGLE_OAUTH_REDIRECT_URI
GOOGLE_OAUTH_REDIRECT_URI=http://localhost:8080/api/auth/google/callback

# ============================================
# Server Configuration
# ============================================
PORT=8080
FRONTEND_ORIGIN=http://localhost:5173
BACKEND_URL=http://localhost:8080

# Секрет для JWT (любая случайная строка)
JWT_SECRET=your-jwt-secret-here

# Секрет для cron jobs (любая случайная строка)
CRON_SECRET=your-cron-secret-here

# ============================================
# Local Storage (для хранения видео на сервере)
# ============================================
# Путь к корневой директории для хранения видео
# По умолчанию (для локальной разработки): ./storage/videos
# Для продакшена: /data/shortsai/videos
# 
# Структура папок:
# <STORAGE_ROOT>/
#   <channelSlug>/                    # Входная папка - сюда сохраняются новые видео
#     <filename>.mp4                  # Входящие файлы для автопубликации
#     ...
#     Загруженные - <channelName>/    # Архивная папка - сюда перемещаются файлы после успешной публикации
#       <filename>.mp4
#       ...
STORAGE_ROOT=/data/shortsai/videos

# ============================================
# Music Clips (Suno API)
# ============================================
# Получи API ключ на https://sunoapi.org
# ВАЖНО: Без этого ключа Music Clips функциональность будет недоступна
SUNO_API_KEY=your_suno_api_key_here
# Базовый URL API (по умолчанию https://api.sunoapi.org согласно документации)
SUNO_API_BASE_URL=https://api.sunoapi.org
# Таймаут для запросов к Suno (мс, по умолчанию 90000 = 90 секунд)
SUNO_REQUEST_TIMEOUT_MS=90000
# Ограничение параллельных запросов к Suno (по умолчанию 1)
MUSIC_CLIPS_SUNO_CONCURRENCY=1
# Задержка между запросами к Suno (мс, по умолчанию 1500)
MUSIC_CLIPS_SUNO_DELAY_MS=1500
# Общий таймаут для пайплайна Music Clips (мс, по умолчанию 1800000 = 30 минут)
MUSIC_CLIPS_PIPELINE_TIMEOUT_MS=1800000

# ============================================
# Публичный URL backend (КРИТИЧНО!)
# ============================================
# ============================================
# BACKEND_URL - Публичный URL для доступа к backend
# ============================================
# ВАЖНО: Для работы с Blotato нужен ПУБЛИЧНЫЙ URL, а не localhost!
# Blotato работает на внешнем сервере и не может получить доступ к localhost:8080
# 
# Схема деплоя (Production):
# - Backend физически работает на Synology NAS (порт 8080 локально)
# - Внешний доступ через VPS со статическим IP (порт 5000)
# - VPS пробрасывает порт 5000 на Synology:8080 (через VPN туннель или напрямую)
# - BACKEND_URL должен указывать на публичный адрес VPS
#
# Примеры для Production (выберите один):
#   BACKEND_URL=http://159.255.37.158:5000
#   BACKEND_URL=http://vm3737624.firstbyte.club:5000
#   BACKEND_URL=https://vm3737624.firstbyte.club:5000  # если настроен SSL
#
# Для локальной разработки можно использовать ngrok:
#   ngrok http 8080
#   BACKEND_URL=https://your-ngrok-url.ngrok.io
#
# Если не указан, будет использован localhost (НЕ РАБОТАЕТ С BLOTATO!)
# BACKEND_URL=http://localhost:8080






